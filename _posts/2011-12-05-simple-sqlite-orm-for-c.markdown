---
layout: post
status: publish
published: true
title: Simple SQLite ORM for C++
author:
  display_name: godexsoft
  login: godexsoft
  email: godexsoft@gmail.com
  url: ''
author_login: godexsoft
author_email: godexsoft@gmail.com
wordpress_id: 194
wordpress_url: http://alex.tapmania.org/?p=194
date: '2011-12-05 23:58:07 +0000'
date_gmt: '2011-12-05 23:58:07 +0000'
categories:
- Development
tags:
- C++
- Xcode
- boost
- ODB
- sqlite
- ORM
- code generation
---
Up until recently I haven't seen any intuitive and easy to use ORM for C++.
However I always wanted to use one in my applications..
mainly for really simple tasks such as leader boards, accounts, profiles, etc.

Ideally the ORM would automagically generate **find** methods for my fields:

{% highlight cpp linenos %}
struct person
{
    int id;
    std::string name;
};

dao<person> d;

person mike = d.find_by_name("Mike");
person valera = d.find_by_id(1);
{% endhighlight %}

Another thing I really would like to have is support for foreign collections:

{% highlight cpp linenos %}
struct blog_post
{
   int id;
   std::string title;
   std::string body;

   person owner;
};

struct person
{
    // ...

    std::vector<blog_post> posts;
};

dao<person> d;
dao<blog_post> pd;

person mike = d.find_by_name("Mike");
std::vector<blog_post> posts = mike.get_posts();

person also_mike = posts.at(0).get_owner();
{% endhighlight %}

Then **get_posts()** and **get_owner()** should be lazy..
because it's both easier to program and easier to use in the simple cases we aim for.  
Another thing I would ask for is **minimum** glue code and verbosity --- we are not
talking about GORM or Hibernate here.. just a very simple ORM for, say, sqlite.  
And of course the database schema should be automatically generated and the database
should be created without me even thinking about it.

So.. main features for a simple ORM:

- Ease of use
- Generation of find methods
- "Has many" and "Belongs to"
- Less glue code and verbosity
- Schema generation and DB creation

Well, C++ limits us a lot when talking about runtime generation.
But we can always use the preprocessor, right?
It definitely leads to non-c++ syntax but at least allows us to generate code.

The closest model declaration I could get is:

{% highlight cpp linenos %}
#undef  MODEL_NAME
#define MODEL_NAME user

BEGIN_MODEL_DECLARATION()
: name("Mike")
, age(21)
{

}

public:
  user(const std::string& n, long a)
  : name(n)
  , age(a)
  {

  }

  static const std::string table_name()
  {
      return "users";
  }

private:
  FIELD_STR(name);
  FIELD_NUM(age);

END_DECLARATION();
{% endhighlight %}

As you can guess it generates a class **"user"** which defines several fields
and exposes a table name. The table name is only used in SQL queries.

The line after the **BEGIN_MODEL_DECLARATION** is the default constructor.  
Every field needs a default value anyway so we set them using the default constructor.
While writing this I realised that I did not think of a way to specify nullable fields. Oh well :-)  
You also need a meaningful constructor for your model.
You always do anyway but in sqlite_orm the default constructor is private and can be only used by the ORM.
As you can see I defined a public constructor too.  
The interesting part here are the **FIELD_*** entries.
As you could guess they specify the type of the field and its name.
They also generate all the **find\_*** methods. The **id** field is implicitly
generated by the ORM because there is no sense in having a table which you can not map by id :-)

If you would want to add some scores to our user:

{% highlight cpp linenos %}
#undef  MODEL_NAME
#define MODEL_NAME user

BEGIN_MODEL_DECLARATION()
// ...
HAS_MANY(score, scores);

END_DECLARATION();
{% endhighlight %}

And the **score** model would be:

{% highlight cpp linenos %}
#undef  MODEL_NAME
#define MODEL_NAME score

BEGIN_MODEL_DECLARATION()
: comment("")
, score_value(0)
, ts( sqlite::orm::sql_date("now") )
{

}

public:
  score_model(user& usr, const std::string& cmnt, long sc)
  : comment(cmnt)
  , score_value(sc)
  , ts( sqlite::orm::sql_date("now") )
  , user_id(usr)

  {

  }

  static const std::string table_name()
  {
      return "scores";
  }

private:
  FIELD_STR(comment);
  FIELD_NUM(score_value);
  FIELD_DATE(ts);

  BELONGS_TO(user, owner);
END_DECLARATION();
{% endhighlight %}

This model has several interesting parts but I was talking about **HAS_MANY**
so look at the end of the code block and note the **BELONGS_TO** macros.  
First argument is the model class and the second argument is the name of the "field" to generate.
There is no real field generated here.. instead a lazy **get_owner()** is generated
and can be used to retrieve the owner of this score.  
Another noteworthy line is **sqlite::orm::sql_date("now")**.
sql_date is a simple wrapper for SQL date representation. It can contain a string like "now"
or "9999-12-31 23:59:59", or it can contain a unix timestamp.

Basically that's all. The ORM is really simple. There are no functions to tune ordering..
no methods to query for a range of values. Just find_all, find_all_by_*, find_by_* and find_first.
However it's really easy to write new generated functions and one could easily add them.

For anyone interested [here](http://tapmania.org/files/boost_orm.tar.gz) is
an xcode project along with sqlite_orm and sqlite3pp on which sqlite_orm is based.

As a last note I would like to say that I started this article with the words
"up until recently" and by that I did not mean my small ORM implementation.  
A couple of days ago, when this little ORM was already implemented, I found ODB.  
ODB is very interesting and offers a lot more flexibility.
If I would need serious database access from C++ I would definitely give it a try.

Check it out [here](http://codesynthesis.com/products/odb/).

Cheers
